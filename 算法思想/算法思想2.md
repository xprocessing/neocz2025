算法思想是解决问题的核心指导原则，以下是最常用的 **8 种算法思想**，每种思想都对应经典场景和算法，理解它们能帮你快速建立解题思路：


### 一、穷举法（Brute Force）
#### 核心思想：
暴力尝试所有可能的解决方案，直到找到正确答案。不追求效率，但保证正确性（只要存在解，一定能找到）。
#### 适用场景：
问题规模小、可能的解数量有限，或没有更优算法时。
#### 经典例子：
- 求质数（遍历 2 到 √n 判断是否整除）；
- 字符串匹配（暴力匹配：逐个对比主串和模式串的字符）；
- 密码破解（尝试所有可能的密码组合）。
#### 特点：
简单直观，编码容易；但时间复杂度高（通常是 O(n!)、O(2ⁿ) 等指数级），不适用于大规模问题。


### 二、贪心算法（Greedy Algorithm）
#### 核心思想：
每一步都做出「当前最优选择」，不考虑未来可能的后果，期望通过局部最优积累出全局最优。
#### 适用场景：
问题具有「贪心选择性质」（局部最优能推出全局最优）和「最优子结构」（全局最优包含子问题最优）。
#### 经典例子：
- 硬币找零（用面额最大的硬币优先支付，如 1、5、10 元找零）；
- 活动选择问题（选择结束时间最早的活动，以容纳更多活动）；
- 哈夫曼编码（每次选频率最低的两个节点合并，生成最优前缀码）。
#### 特点：
效率高（通常是线性或多项式时间）；但**不一定总能得到全局最优解**（如硬币找零问题中，若硬币面额为 1、3、4，找零 6 元：贪心会选 4+1+1，而最优是 3+3），需谨慎验证问题是否满足贪心性质。


### 三、分治法（Divide and Conquer）
#### 核心思想：
将复杂问题「分解」为多个规模较小的子问题（子问题与原问题结构相同），「解决」每个子问题，最后将子问题的解「合并」为原问题的解。
#### 适用场景：
问题具有「最优子结构」，且分解后的子问题相互独立（无重叠）。
#### 经典例子：
- 归并排序（分解：将数组分成两半；解决：递归排序两半；合并：合并两个有序数组）；
- 快速排序（分解：选基准元素划分数组；解决：递归排序左右子数组；合并：无需合并，划分后已部分有序）；
- 二分查找（分解：取数组中点；解决：判断目标在左/右子数组，递归查找；合并：直接返回找到的位置）。
#### 特点：
时间复杂度通常为 O(n log n)（通过递归树分析，分解和合并的代价可控）；但递归调用会产生额外空间开销（函数栈），需注意栈溢出问题。


### 四、动态规划（Dynamic Programming, DP）
#### 核心思想：
将复杂问题分解为「重叠子问题」（子问题重复出现），通过「状态转移方程」记录子问题的最优解（避免重复计算），最终推导出全局最优解。核心是「记忆化存储」（缓存子问题结果）。
#### 适用场景：
问题具有「最优子结构」和「重叠子问题」（这是与分治法的核心区别：分治法子问题独立，DP 子问题重叠）。
#### 经典例子：
- 斐波那契数列（递归会重复计算 F(n-2)、F(n-3) 等，DP 用数组存储已计算的 F(k)）；
- 最长公共子序列（LCS：用 dp[i][j] 表示字符串前 i 位和前 j 位的 LCS 长度，通过状态转移方程推导）；
- 背包问题（0-1 背包：用 dp[i][j] 表示前 i 个物品、容量 j 时的最大价值；完全背包：允许物品重复选择，调整状态转移方向）。
#### 特点：
高效（将指数级时间复杂度降为多项式级，如 O(n²)）；但需设计清晰的「状态」和「转移方程」，空间复杂度可能较高（可通过「滚动数组」优化空间）。


### 五、回溯法（Backtracking）
#### 核心思想：
类似「深度优先搜索（DFS）」，尝试逐步构建解决方案，当发现当前选择无法得到有效解时，「回溯」到上一步，换一种选择继续尝试。本质是「穷举 + 剪枝」。
#### 适用场景：
解决「组合、排列、子集」等需要探索所有可能解的问题，或约束条件较多的问题（可通过剪枝减少无效探索）。
#### 经典例子：
- 八皇后问题（在 8x8 棋盘上放置皇后，使其不互相攻击，通过回溯尝试每个位置，不符合则回退）；
- 全排列（生成数组的所有排列，通过回溯交换元素位置，探索所有可能顺序）；
- 子集和问题（找出数组中所有和为目标值的子集，通过回溯选择是否包含当前元素）。
#### 特点：
能找到所有可能解；但时间复杂度高（通常是 O(n!) 或 O(2ⁿ)），通过「剪枝」（如提前判断当前路径和已超过目标值，直接放弃后续探索）可优化效率。


### 六、分支限界法（Branch and Bound）
#### 核心思想：
类似回溯法，但更注重「优化」—— 不仅探索解，还通过「下界/上界」判断当前分支是否可能找到比已有最优解更好的解，若不可能则「剪枝」（不再探索该分支）。通常用「广度优先搜索（BFS）」或「优先队列（堆）」实现。
#### 适用场景：
解决「组合优化问题」（如最大化收益、最小化成本），需要找到最优解而非所有解。
#### 经典例子：
- 旅行商问题（TSP：找到经过所有城市且路径最短的回路，通过分支限界剪去不可能优于当前最短路径的分支）；
- 0-1 背包问题（用优先队列存储每个分支的价值上界，优先探索价值高的分支，提前剪去价值低于当前最优解的分支）。
#### 特点：
比回溯法更高效（剪枝更激进），但需要设计合理的「界函数」（计算分支的上下界），否则剪枝效果不佳。


### 七、概率算法（Probabilistic Algorithm）
#### 核心思想：
引入随机性（如随机选择、随机采样）来解决问题，不保证每次运行都得到正确解，但在大概率下能得到满意解（或期望时间内找到解）。
#### 适用场景：
精确算法效率极低，或问题本身允许一定误差（如近似计算）。
#### 经典例子：
- 蒙特卡洛算法（如用随机投点法计算 π 值：在正方形内随机投点，统计落在圆内的比例，近似 π/4）；
- 拉斯维加斯算法（如随机快速排序：随机选择基准元素，避免最坏情况（O(n²)），期望时间复杂度 O(n log n)）；
- 素数测试（米勒-拉宾素数测试：通过随机选择基数检测是否为素数，大概率避免误判）。
#### 特点：
效率高（期望时间复杂度低）；但需接受「概率性正确」，适用于对结果正确性要求不绝对严格的场景（或通过多次运行降低错误概率）。


### 八、迭代法（Iterative Method）
#### 核心思想：
通过「循环迭代」逐步逼近问题的解，直到满足收敛条件（如误差小于阈值）。无需递归，直接用循环更新解的值。
#### 适用场景：
问题无法直接求解，但可通过逐步迭代逼近答案（如方程求解、数值优化）。
#### 经典例子：
- 牛顿迭代法（求解方程 f(x)=0 的根：通过 f(xₙ) 的切线方程迭代更新 xₙ₊₁，快速收敛到根）；
- 梯度下降法（机器学习中的优化算法：沿梯度方向迭代更新参数，最小化损失函数）；
- 迭代法求斐波那契数列（用循环代替递归，避免重复计算，空间复杂度 O(1)）。
#### 特点：
效率高、空间开销小（无递归栈）；但需确保迭代过程「收敛」（否则会无限循环），需合理设置收敛条件和初始值。


### 总结：算法思想的选择优先级
1. 先判断问题是否有「贪心性质」，若有则用贪心（最简单高效）；
2. 若无，看是否有「重叠子问题」，若有则用动态规划（避免重复计算）；
3. 若子问题独立，用分治法（适合大规模分解）；
4. 若需要探索所有可能解，用回溯法（或分支限界法优化）；
5. 若精确解效率极低，考虑概率算法（牺牲部分正确性换效率）；
6. 数值计算类问题优先用迭代法（收敛快、空间省）。

理解这些思想的核心逻辑，能帮你在面对新问题时快速定位解题方向，选择最合适的算法策略。