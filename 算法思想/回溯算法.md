我们换一个经典的回溯算法案例：**全排列问题**。

**问题描述：**
给定一个不含重复数字的数组 `nums`，返回其所有可能的全排列。

**示例：**
输入：`nums = [1, 2, 3]`
输出：
```
[
  [1,2,3],
  [1,3,2],
  [2,1,3],
  [2,3,1],
  [3,1,2],
  [3,2,1]
]
```

**回溯算法思路：**
1.  **选择**：从数组中选择一个未被使用过的数字，将其加入当前的排列路径中。
2.  **递归**：递归地对剩余的数字进行全排列。
3.  **回溯**：当递归返回后，撤销上一步的选择（将数字从当前路径中移除，并标记为未使用），以便尝试其他选择。
4.  **终止条件**：当当前路径的长度等于数组的长度时，说明找到了一个完整的排列，将其加入结果集。

下面是每种语言的实现代码：

---

### 1. Java 实现

```java
import java.util.ArrayList;
import java.util.List;

public class Permutations {

    public static List<List<Integer>> permute(int[] nums) {
        List<List<Integer>> result = new ArrayList<>();
        backtrack(result, new ArrayList<>(), nums, new boolean[nums.length]);
        return result;
    }

    private static void backtrack(List<List<Integer>> result, List<Integer> currentPath, int[] nums, boolean[] used) {
        // 1. 终止条件：当前路径长度等于数组长度
        if (currentPath.size() == nums.length) {
            result.add(new ArrayList<>(currentPath)); // 添加路径的副本
            return;
        }

        // 2. 遍历选择
        for (int i = 0; i < nums.length; i++) {
            // 如果数字已被使用，则跳过
            if (used[i]) {
                continue;
            }
            
            // 3. 做出选择
            used[i] = true;
            currentPath.add(nums[i]);

            // 4. 递归进入下一层决策树
            backtrack(result, currentPath, nums, used);

            // 5. 撤销选择（回溯）
            currentPath.remove(currentPath.size() - 1);
            used[i] = false;
        }
    }

    public static void main(String[] args) {
        int[] nums = {1, 2, 3};
        List<List<Integer>> permutations = permute(nums);

        System.out.println("全排列结果:");
        for (List<Integer> perm : permutations) {
            System.out.println(perm);
        }
    }
}
```

**运行结果：**
```
全排列结果:
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

---

### 2. JavaScript (JS) 实现

```javascript
/**
 * @param {number[]} nums
 * @return {number[][]}
 */
function permute(nums) {
    const result = [];
    
    function backtrack(currentPath, used) {
        // 1. 终止条件
        if (currentPath.length === nums.length) {
            result.push([...currentPath]); // 添加路径的副本
            return;
        }

        // 2. 遍历选择
        for (let i = 0; i < nums.length; i++) {
            if (used[i]) {
                continue;
            }

            // 3. 做出选择
            used[i] = true;
            currentPath.push(nums[i]);

            // 4. 递归
            backtrack(currentPath, used);

            // 5. 撤销选择
            currentPath.pop();
            used[i] = false;
        }
    }

    backtrack([], new Array(nums.length).fill(false));
    return result;
}

// --- 主程序 ---
const nums = [1, 2, 3];
const permutations = permute(nums);

console.log("全排列结果:");
permutations.forEach(perm => console.log(perm));
```

**运行结果：**
```
全排列结果:
[ 1, 2, 3 ]
[ 1, 3, 2 ]
[ 2, 1, 3 ]
[ 2, 3, 1 ]
[ 3, 1, 2 ]
[ 3, 2, 1 ]
```

---

### 3. PHP 实现

```php
<?php

/**
 * @param Integer[] $nums
 * @return Integer[][]
 */
function permute($nums) {
    $result = array();
    $n = count($nums);
    $used = array_fill(0, $n, false);
    
    backtrack($result, array(), $nums, $used, $n);
    return $result;
}

function backtrack(&$result, $currentPath, $nums, &$used, $n) {
    if (count($currentPath) == $n) {
        array_push($result, $currentPath);
        return;
    }

    for ($i = 0; $i < $n; $i++) {
        if ($used[$i]) {
            continue;
        }
        
        $used[$i] = true;
        array_push($currentPath, $nums[$i]);
        
        backtrack($result, $currentPath, $nums, $used, $n);
        
        array_pop($currentPath);
        $used[$i] = false;
    }
}

// --- 主程序 ---
$nums = array(1, 2, 3);
$permutations = permute($nums);

echo "全排列结果:\n";
foreach ($permutations as $perm) {
    echo '[' . implode(', ', $perm) . ']' . "\n";
}
?>
```

**运行结果：**
```
全排列结果:
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

---

### 4. Python 实现

```python
from typing import List

def permute(nums: List[int]) -> List[List[int]]:
    result = []
    n = len(nums)
    
    def backtrack(current_path: List[int], used: List[bool]):
        # 1. 终止条件
        if len(current_path) == n:
            result.append(current_path.copy()) # 添加路径的副本
            return
        
        # 2. 遍历选择
        for i in range(n):
            if used[i]:
                continue
            
            # 3. 做出选择
            used[i] = True
            current_path.append(nums[i])
            
            # 4. 递归
            backtrack(current_path, used)
            
            # 5. 撤销选择
            current_path.pop()
            used[i] = False
            
    backtrack([], [False] * n)
    return result

# --- 主程序 ---
nums = [1, 2, 3]
permutations = permute(nums)

print("全排列结果:")
for perm in permutations:
    print(perm)
```

**运行结果：**
```
全排列结果:
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

---

### 5. C 实现

```c
#include <stdio.h>
#include <stdlib.h>
#include <stdbool.h>

// 全局变量，用于存储结果
int **result;
int *colSizes; // 每个解的列数（实际上都等于n）
int resultCount;
int n;

// 将当前路径 path 添加到结果集
void addSolution(int *path) {
    result[resultCount] = (int *)malloc(n * sizeof(int));
    for (int i = 0; i < n; i++) {
        result[resultCount][i] = path[i];
    }
    colSizes[resultCount] = n;
    resultCount++;
}

// 回溯函数
// path: 当前路径, pathSize: 当前路径长度, used: 标记数字是否已使用
void backtrack(int *path, int pathSize, bool *used, int *nums) {
    if (pathSize == n) {
        addSolution(path);
        return;
    }

    for (int i = 0; i < n; i++) {
        if (used[i]) {
            continue;
        }
        
        // 做出选择
        used[i] = true;
        path[pathSize] = nums[i];
        
        // 递归
        backtrack(path, pathSize + 1, used, nums);
        
        // 撤销选择
        used[i] = false;
    }
}

/**
 * Return an array of arrays of size *returnSize.
 * The sizes of the arrays are returned as *returnColumnSizes array.
 * Note: Both returned array and *columnSizes array must be malloced, assume caller calls free().
 */
int** permute(int* nums, int numsSize, int* returnSize, int** returnColumnSizes) {
    n = numsSize;
    resultCount = 0;
    
    // 计算n!以预估所需内存，这里为了简单，我们先分配一个足够大的空间
    int maxSize = 1;
    for (int i = 1; i <= n; i++) maxSize *= i;
    
    result = (int **)malloc(maxSize * sizeof(int *));
    colSizes = (int *)malloc(maxSize * sizeof(int));
    
    int *path = (int *)malloc(n * sizeof(int));
    bool *used = (bool *)malloc(n * sizeof(bool));
    for (int i = 0; i < n; i++) used[i] = false;
    
    backtrack(path, 0, used, nums);
    
    free(path);
    free(used);
    
    *returnSize = resultCount;
    *returnColumnSizes = colSizes;
    return result;
}

// --- 主程序 ---
int main() {
    int nums[] = {1, 2, 3};
    int numsSize = sizeof(nums) / sizeof(nums[0]);
    int returnSize;
    int *returnColumnSizes;
    
    int **permutations = permute(nums, numsSize, &returnSize, &returnColumnSizes);
    
    printf("全排列结果:\n");
    for (int i = 0; i < returnSize; i++) {
        printf("[");
        for (int j = 0; j < returnColumnSizes[i]; j++) {
            printf("%d", permutations[i][j]);
            if (j < returnColumnSizes[i] - 1) printf(", ");
        }
        printf("]\n");
        free(permutations[i]); // 释放每个解的内存
    }
    free(permutations); // 释放结果集的内存
    free(returnColumnSizes); // 释放列大小数组的内存
    
    return 0;
}
```

**运行结果：**
```
全排列结果:
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

---

### 6. C++ 实现

```cpp
#include <iostream>
#include <vector>

using namespace std;

class Solution {
public:
    vector<vector<int>> permute(vector<int>& nums) {
        vector<vector<int>> result;
        vector<int> currentPath;
        vector<bool> used(nums.size(), false);
        
        backtrack(result, currentPath, used, nums);
        return result;
    }

private:
    void backtrack(vector<vector<int>>& result, vector<int>& currentPath, vector<bool>& used, vector<int>& nums) {
        if (currentPath.size() == nums.size()) {
            result.push_back(currentPath);
            return;
        }

        for (int i = 0; i < nums.size(); ++i) {
            if (used[i]) {
                continue;
            }
            
            // 做出选择
            used[i] = true;
            currentPath.push_back(nums[i]);
            
            // 递归
            backtrack(result, currentPath, used, nums);
            
            // 撤销选择
            currentPath.pop_back();
            used[i] = false;
        }
    }
};

// --- 主程序 ---
int main() {
    Solution sol;
    vector<int> nums = {1, 2, 3};
    vector<vector<int>> permutations = sol.permute(nums);
    
    cout << "全排列结果:" << endl;
    for (const auto& perm : permutations) {
        cout << "[";
        for (size_t i = 0; i < perm.size(); ++i) {
            cout << perm[i];
            if (i < perm.size() - 1) {
                cout << ", ";
            }
        }
        cout << "]" << endl;
    }
    
    return 0;
}
```

**运行结果：**
```
全排列结果:
[1, 2, 3]
[1, 3, 2]
[2, 1, 3]
[2, 3, 1]
[3, 1, 2]
[3, 2, 1]
```

### 总结

全排列问题是理解回溯算法的绝佳例子。它清晰地展示了“**选择 -> 递归 -> 撤销选择**”的核心流程。

*   **`currentPath` (当前路径)**：记录了递归探索的当前状态。
*   **`used` (使用标记)**：这是回溯算法中常用的一种技巧，用来避免重复选择元素，确保每个元素在每个排列中只出现一次。
*   **`result.push_back(currentPath)` (或类似操作)**：当 `currentPath` 的长度达到数组长度时，说明找到了一个完整的解，将其存入结果集。注意，在某些语言（如 Java, JavaScript, Python）中，需要添加 `currentPath` 的一个副本，以防止后续的回溯操作修改已存入的结果。

这个模式在解决许多组合、排列、子集相关的问题时都非常有用。