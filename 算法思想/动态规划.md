我们来用 **Java、JavaScript、Python、C、C++** 五种语言分别实现一个经典的动态规划问题：**0-1 背包问题**。

### 0-1 背包问题描述

有一个背包，它的容量为 `W`。现在有 `N` 个物品，每个物品都有自己的重量 `w[i]` 和价值 `v[i]`。

**问题：** 从这 `N` 个物品中选择一部分物品放入背包，使得放入物品的总重量不超过背包的容量 `W`，并且使得放入物品的总价值最大。

**注意：** 每个物品只能选择放入或不放入，不能放入多次，这就是“0-1”的由来。

---

### 动态规划解题思路

我们可以定义一个二维数组 `dp` 来存储子问题的解。

- `dp[i][j]` 表示：对于前 `i` 个物品，在背包容量为 `j` 的情况下，能够获得的最大价值。

**状态转移方程：**

对于第 `i` 个物品，我们有两个选择：

1.  **不放入背包：** 那么 `dp[i][j]` 的值就等于 `dp[i-1][j]`，即前 `i-1` 个物品在容量 `j` 时的最大价值。
2.  **放入背包：** 那么我们需要看背包是否能装下它。如果 `j >= w[i]`，那么放入后，背包的剩余容量是 `j - w[i]`，我们可以再加上前 `i-1` 个物品在剩余容量 `j - w[i]` 时的最大价值 `dp[i-1][j - w[i]]`，再加上当前物品的价值 `v[i]`。所以总价值是 `v[i] + dp[i-1][j - w[i]]`。

`dp[i][j]` 应该取这两种选择中的最大值。

**数学表达：**
`dp[i][j] = max(dp[i-1][j], (j >= w[i] ? v[i] + dp[i-1][j - w[i]] : 0))`

**初始化：**
- `dp[0][j] = 0`：没有物品可选时，无论背包容量多大，总价值都是 0。
- `dp[i][0] = 0`：背包容量为 0 时，无法放入任何物品，总价值也是 0。

**最终答案：**
`dp[N][W]` 就是我们想要的结果，即考虑所有 `N` 个物品，在背包容量为 `W` 时能获得的最大价值。

---

### Java 实现

```java
public class KnapsackDP {

    /**
     * 0-1 背包问题动态规划实现
     * @param W 背包最大容量
     * @param weights 物品重量数组
     * @param values 物品价值数组
     * @return 能获得的最大价值
     */
    public static int knapsack(int W, int[] weights, int[] values) {
        // 物品数量
        int n = values.length;

        // dp[i][j] 表示前 i 个物品在容量为 j 时的最大价值
        int[][] dp = new int[n + 1][W + 1];

        // 填充 dp 表
        for (int i = 1; i <= n; i++) {
            for (int j = 1; j <= W; j++) {
                // 不选择第 i 个物品
                dp[i][j] = dp[i - 1][j];

                // 如果第 i 个物品的重量小于等于当前背包容量 j，则考虑选择它
                if (weights[i - 1] <= j) {
                    // 选择第 i 个物品的价值 = 第 i 个物品的价值 + 前 i-1 个物品在容量 j - weights[i-1] 时的最大价值
                    int valueWithItem = values[i - 1] + dp[i - 1][j - weights[i - 1]];
                    // 取两者中的较大值
                    dp[i][j] = Math.max(dp[i][j], valueWithItem);
                }
            }
        }

        // 打印 DP 表（可选）
        printDPTable(dp);
        
        return dp[n][W];
    }
    
    // 辅助方法：打印 DP 表，方便调试和理解
    private static void printDPTable(int[][] dp) {
        System.out.println("Dynamic Programming Table:");
        for (int[] row : dp) {
            for (int val : row) {
                System.out.printf("%4d", val);
            }
            System.out.println();
        }
    }

    public static void main(String[] args) {
        // 示例
        int[] values = {60, 100, 120};    // 物品价值
        int[] weights = {10, 20, 30};     // 物品重量
        int W = 50;                       // 背包容量

        int maxValue = knapsack(W, weights, values);
        System.out.println("能放入背包的最大价值为: " + maxValue); // 预期输出: 220 (100 + 120)
    }
}
```

---

### JavaScript 实现

```javascript
/**
 * 0-1 背包问题动态规划实现
 * @param {number} W 背包最大容量
 * @param {number[]} weights 物品重量数组
 * @param {number[]} values 物品价值数组
 * @return {number} 能获得的最大价值
 */
function knapsack(W, weights, values) {
    const n = values.length;

    // dp[i][j] 表示前 i 个物品在容量为 j 时的最大价值
    // 在 JavaScript 中，我们可以创建一个二维数组
    const dp = new Array(n + 1);
    for (let i = 0; i <= n; i++) {
        dp[i] = new Array(W + 1).fill(0);
    }

    // 填充 dp 表
    for (let i = 1; i <= n; i++) {
        for (let j = 1; j <= W; j++) {
            // 不选择第 i 个物品
            dp[i][j] = dp[i - 1][j];

            // 如果可以选择第 i 个物品
            if (weights[i - 1] <= j) {
                const valueWithItem = values[i - 1] + dp[i - 1][j - weights[i - 1]];
                dp[i][j] = Math.max(dp[i][j], valueWithItem);
            }
        }
    }
    
    // 打印 DP 表（可选）
    printDPTable(dp);

    return dp[n][W];
}

// 辅助方法：打印 DP 表
function printDPTable(dp) {
    console.log("Dynamic Programming Table:");
    dp.forEach(row => {
        console.log(row.join('\t'));
    });
}

// 示例
const values = [60, 100, 120];
const weights = [10, 20, 30];
const W = 50;

const maxValue = knapsack(W, weights, values);
console.log("能放入背包的最大价值为:", maxValue); // 预期输出: 220
```

---

### Python 实现

```python
def knapsack(W, weights, values):
    """
    0-1 背包问题动态规划实现
    :param W: 背包最大容量
    :param weights: 物品重量列表
    :param values: 物品价值列表
    :return: 能获得的最大价值
    """
    n = len(values)

    # dp[i][j] 表示前 i 个物品在容量为 j 时的最大价值
    # Python 中可以用列表推导式快速创建二维列表
    dp = [[0 for _ in range(W + 1)] for _ in range(n + 1)]

    # 填充 dp 表
    for i in range(1, n + 1):
        for j in range(1, W + 1):
            # 不选择第 i 个物品
            dp[i][j] = dp[i - 1][j]

            # 如果可以选择第 i 个物品
            if weights[i - 1] <= j:
                value_with_item = values[i - 1] + dp[i - 1][j - weights[i - 1]]
                dp[i][j] = max(dp[i][j], value_with_item)

    # 打印 DP 表（可选）
    print_dp_table(dp)
    
    return dp[n][W]

# 辅助方法：打印 DP 表
def print_dp_table(dp):
    print("Dynamic Programming Table:")
    for row in dp:
        print("{0:4d}".format(row[0]), end="")
        for val in row[1:]:
            print("{0:4d}".format(val), end="")
        print()

# 示例
values = [60, 100, 120]
weights = [10, 20, 30]
W = 50

max_value = knapsack(W, weights, values)
print(f"能放入背包的最大价值为: {max_value}")  # 预期输出: 220

```

---

### C 实现

```c
#include <stdio.h>
#include <stdlib.h>

#define MAX(a, b) ((a) > (b) ? (a) : (b))

/**
 * 0-1 背包问题动态规划实现
 * @param W 背包最大容量
 * @param n 物品数量
 * @param weights 物品重量数组
 * @param values 物品价值数组
 * @return 能获得的最大价值
 */
int knapsack(int W, int n, int weights[], int values[]) {
    // dp[i][j] 表示前 i 个物品在容量为 j 时的最大价值
    int** dp = (int**)malloc((n + 1) * sizeof(int*));
    for (int i = 0; i <= n; i++) {
        dp[i] = (int*)calloc(W + 1, sizeof(int)); // calloc 会初始化为 0
    }

    // 填充 dp 表
    for (int i = 1; i <= n; i++) {
        for (int j = 1; j <= W; j++) {
            // 不选择第 i 个物品
            dp[i][j] = dp[i - 1][j];

            // 如果可以选择第 i 个物品
            if (weights[i - 1] <= j) {
                int value_with_item = values[i - 1] + dp[i - 1][j - weights[i - 1]];
                dp[i][j] = MAX(dp[i][j], value_with_item);
            }
        }
    }
    
    // 打印 DP 表（可选）
    print_dp_table(dp, n, W);

    int result = dp[n][W];
    
    // 释放分配的内存
    for (int i = 0; i <= n; i++) {
        free(dp[i]);
    }
    free(dp);

    return result;
}

// 辅助方法：打印 DP 表
void print_dp_table(int** dp, int n, int W) {
    printf("Dynamic Programming Table:\n");
    for (int i = 0; i <= n; i++) {
        for (int j = 0; j <= W; j++) {
            printf("%4d", dp[i][j]);
        }
        printf("\n");
    }
}

int main() {
    // 示例
    int values[] = {60, 100, 120};
    int weights[] = {10, 20, 30};
    int W = 50;
    int n = sizeof(values) / sizeof(values[0]);

    int max_value = knapsack(W, n, weights, values);
    printf("能放入背包的最大价值为: %d\n", max_value); // 预期输出: 220

    return 0;
}
```

---

### C++ 实现

```cpp
#include <iostream>
#include <vector>
#include <algorithm> // for std::max

// 为了方便打印，我们可以创建一个打印函数
void printDPTable(const std::vector<std::vector<int>>& dp) {
    std::cout << "Dynamic Programming Table:" << std::endl;
    for (const auto& row : dp) {
        for (int val : row) {
            std::cout << std::setw(4) << val; // 使用 setw 来格式化输出，需要 <iomanip>
        }
        std::cout << std::endl;
    }
}

/**
 * 0-1 背包问题动态规划实现
 * @param W 背包最大容量
 * @param weights 物品重量向量
 * @param values 物品价值向量
 * @return 能获得的最大价值
 */
int knapsack(int W, const std::vector<int>& weights, const std::vector<int>& values) {
    int n = values.size();

    // dp[i][j] 表示前 i 个物品在容量为 j 时的最大价值
    // 使用 vector of vectors，会自动初始化为 0
    std::vector<std::vector<int>> dp(n + 1, std::vector<int>(W + 1, 0));

    // 填充 dp 表
    for (int i = 1; i <= n; ++i) {
        for (int j = 1; j <= W; ++j) {
            // 不选择第 i 个物品
            dp[i][j] = dp[i - 1][j];

            // 如果可以选择第 i 个物品
            if (weights[i - 1] <= j) {
                int valueWithItem = values[i - 1] + dp[i - 1][j - weights[i - 1]];
                dp[i][j] = std::max(dp[i][j], valueWithItem);
            }
        }
    }
    
    // 打印 DP 表（可选）
    // printDPTable(dp); // 取消注释以打印

    return dp[n][W];
}

int main() {
    // 示例
    std::vector<int> values = {60, 100, 120};
    std::vector<int> weights = {10, 20, 30};
    int W = 50;

    int maxValue = knapsack(W, weights, values);
    std::cout << "能放入背包的最大价值为: " << maxValue << std::endl; // 预期输出: 220

    return 0;
}
// 注意：如果要使用 printDPTable 中的 std::setw，需要在文件顶部添加 #include <iomanip>
```

### 总结与优化

上面给出的实现是最经典、最易于理解的二维动态规划解法。其时间复杂度为 O(N*W)，空间复杂度也为 O(N*W)。

**空间优化：**

注意到在计算 `dp[i][...]` 时，我们只用到了 `dp[i-1][...]` 的信息。这意味着我们可以使用一个一维数组来优化空间复杂度。

定义 `dp[j]` 表示在背包容量为 `j` 时的最大价值。

**状态转移方程（一维）：**
为了防止同一个物品被多次放入（这会变成完全背包问题），我们需要从后往前遍历容量 `j`。

`for (int j = W; j >= weights[i-1]; --j)`
`{`
    `dp[j] = max(dp[j], values[i-1] + dp[j - weights[i-1]]);`
`}`

这个优化将空间复杂度从 O(N*W) 降低到了 O(W)。如果背包容量 `W` 很大，这个优化效果会非常显著。你可以尝试用这个思路对上面的代码进行修改。