# 用java，js，php，python，c，c++ 5种语言实现枚举算法
我们来用 **Java, JavaScript, PHP, Python, C, C++** 这六种语言分别实现一个简单的枚举算法示例。

**示例问题：**
找出 1 到 100 之间的所有质数。

**枚举算法思路：**
1.  遍历 1 到 100 之间的每一个整数。
2.  对于每一个整数 `n`，判断它是否为质数。
3.  判断一个数 `n` 是否为质数的方法：
    *   如果 `n` 小于 2，它不是质数。
    *   从 2 开始，一直到 `sqrt(n)`，尝试用这些数去整除 `n`。
    *   如果能被其中任何一个数整除，那么 `n` 不是质数。
    *   如果遍历完所有可能的除数都不能整除 `n`，那么 `n` 是质数。
4.  收集所有判断为质数的数并输出。

下面是每种语言的实现代码：

---

### 1. Java 实现

```java
import java.util.ArrayList;
import java.util.List;

public class PrimeEnumerator {

    /**
     * 判断一个数是否为质数
     * @param n 需要判断的数
     * @return 如果是质数返回 true，否则返回 false
     */
    private static boolean isPrime(int n) {
        if (n <= 1) {
            return false;
        }
        // 只需检查到 sqrt(n)
        for (int i = 2; i <= Math.sqrt(n); i++) {
            if (n % i == 0) {
                return false;
            }
        }
        return true;
    }

    public static void main(String[] args) {
        int maxNumber = 100;
        List<Integer> primes = new ArrayList<>();

        System.out.println("开始枚举 " + maxNumber + " 以内的质数...");
        
        // 枚举 1 到 maxNumber
        for (int i = 1; i <= maxNumber; i++) {
            if (isPrime(i)) {
                primes.add(i);
            }
        }

        System.out.println("找到的质数有：");
        System.out.println(primes);
    }
}
```

**运行结果：**
```
开始枚举 100 以内的质数...
找到的质数有：
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
```

---

### 2. JavaScript (JS) 实现

```javascript
/**
 * 判断一个数是否为质数
 * @param {number} n 需要判断的数
 * @returns {boolean} 如果是质数返回 true，否则返回 false
 */
function isPrime(n) {
    if (n <= 1) {
        return false;
    }
    // 只需检查到 sqrt(n)
    for (let i = 2; i <= Math.sqrt(n); i++) {
        if (n % i === 0) {
            return false;
        }
    }
    return true;
}

const maxNumber = 100;
const primes = [];

console.log(`开始枚举 ${maxNumber} 以内的质数...`);

// 枚举 1 到 maxNumber
for (let i = 1; i <= maxNumber; i++) {
    if (isPrime(i)) {
        primes.push(i);
    }
}

console.log("找到的质数有：");
console.log(primes);
```

**运行结果 (在浏览器控制台或 Node.js 中)：**
```
开始枚举 100 以内的质数...
找到的质数有：
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
```

---

### 3. PHP 实现

```php
<?php

/**
 * 判断一个数是否为质数
 * @param int $n 需要判断的数
 * @return bool 如果是质数返回 true，否则返回 false
 */
function isPrime($n) {
    if ($n <= 1) {
        return false;
    }
    // 只需检查到 sqrt(n)
    for ($i = 2; $i <= sqrt($n); $i++) {
        if ($n % $i == 0) {
            return false;
        }
    }
    return true;
}

$maxNumber = 100;
$primes = array();

echo "开始枚举 " . $maxNumber . " 以内的质数...\n";

// 枚举 1 到 maxNumber
for ($i = 1; $i <= $maxNumber; $i++) {
    if (isPrime($i)) {
        array_push($primes, $i);
    }
}

echo "找到的质数有：\n";
print_r($primes);
?>
```

**运行结果 (在命令行中 `php prime_enum.php`)：**
```
开始枚举 100 以内的质数...
找到的质数有：
Array
(
    [0] => 2
    [1] => 3
    [2] => 5
    [3] => 7
    [4] => 11
    [5] => 13
    [6] => 17
    [7] => 19
    [8] => 23
    [9] => 29
    [10] => 31
    [11] => 37
    [12] => 41
    [13] => 43
    [14] => 47
    [15] => 53
    [16] => 59
    [17] => 61
    [18] => 67
    [19] => 71
    [20] => 73
    [21] => 79
    [22] => 83
    [23] => 89
    [24] => 97
)
```

---

### 4. Python 实现

```python
import math

def is_prime(n):
    """
    判断一个数是否为质数
    :param n: 需要判断的数
    :return: 如果是质数返回 True，否则返回 False
    """
    if n <= 1:
        return False
    # 只需检查到 sqrt(n)
    for i in range(2, int(math.sqrt(n)) + 1):
        if n % i == 0:
            return False
    return True

max_number = 100
primes = []

print(f"开始枚举 {max_number} 以内的质数...")

# 枚举 1 到 max_number
for i in range(1, max_number + 1):
    if is_prime(i):
        primes.append(i)

print("找到的质数有：")
print(primes)

```

**运行结果：**
```
开始枚举 100 以内的质数...
找到的质数有：
[2, 3, 5, 7, 11, 13, 17, 19, 23, 29, 31, 37, 41, 43, 47, 53, 59, 61, 67, 71, 73, 79, 83, 89, 97]
```

---

### 5. C 实现

```c
#include <stdio.h>
#include <stdbool.h> // 为了使用 bool, true, false
#include <math.h>    // 为了使用 sqrt

/**
 * 判断一个数是否为质数
 * @param n 需要判断的数
 * @return 如果是质数返回 true，否则返回 false
 */
bool isPrime(int n) {
    if (n <= 1) {
        return false;
    }
    // 只需检查到 sqrt(n)
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    int maxNumber = 100;

    printf("开始枚举 %d 以内的质数...\n", maxNumber);
    printf("找到的质数有：\n");

    // 枚举 1 到 maxNumber
    for (int i = 1; i <= maxNumber; i++) {
        if (isPrime(i)) {
            printf("%d ", i);
        }
    }
    printf("\n");

    return 0;
}
```

**编译与运行：**
```bash
gcc -o prime_enum prime_enum.c -lm
./prime_enum
```
**运行结果：**
```
开始枚举 100 以内的质数...
找到的质数有：
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
```
> 注意：在某些编译器上，使用 `sqrt` 函数需要链接数学库，即添加 `-lm` 选项。

---

### 6. C++ 实现

```cpp
#include <iostream>
#include <vector>
#include <cmath>     // 为了使用 sqrt
#include <iomanip>   // 为了使用 std::boolalpha (虽然本例中未用)

/**
 * 判断一个数是否为质数
 * @param n 需要判断的数
 * @return 如果是质数返回 true，否则返回 false
 */
bool isPrime(int n) {
    if (n <= 1) {
        return false;
    }
    // 只需检查到 sqrt(n)
    for (int i = 2; i <= sqrt(n); i++) {
        if (n % i == 0) {
            return false;
        }
    }
    return true;
}

int main() {
    int maxNumber = 100;
    std::vector<int> primes;

    std::cout << "开始枚举 " << maxNumber << " 以内的质数..." << std::endl;
    
    // 枚举 1 到 maxNumber
    for (int i = 1; i <= maxNumber; i++) {
        if (isPrime(i)) {
            primes.push_back(i);
        }
    }

    std::cout << "找到的质数有：" << std::endl;
    for (int prime : primes) { // C++11 范围 for 循环
        std::cout << prime << " ";
    }
    std::cout << std::endl;

    return 0;
}
```

**编译与运行：**
```bash
g++ -o prime_enum_cpp prime_enum.cpp
./prime_enum_cpp
```
**运行结果：**
```
开始枚举 100 以内的质数...
找到的质数有：
2 3 5 7 11 13 17 19 23 29 31 37 41 43 47 53 59 61 67 71 73 79 83 89 97 
```

### 总结

以上六个例子都遵循了同样的枚举算法逻辑：

1.  **定义目标**：明确要寻找什么（100以内的质数）。
2.  **循环遍历**：通过 `for` 循环遍历所有可能的候选解（从 1 到 100）。
3.  **条件判断**：对每个候选解，使用一个辅助函数（`isPrime`）来判断它是否满足我们的条件（是质数）。这个辅助函数本身也可以看作是一个针对“是否为质数”问题的小枚举。
4.  **收集结果**：将满足条件的解收集起来（存入数组、列表或向量）。
5.  **输出结果**：将收集到的所有解打印出来。

这个模式在解决许多问题时都非常有效，尤其是当问题的规模不大，或者没有找到更高效的算法时。